



      
  <div id="readme" class="Box-body readme blob js-code-block-container">
    <article class="markdown-body entry-content p-3 p-md-6" itemprop="text"><h2><a id="user-content-домашнее-задание" class="anchor" aria-hidden="true" href="#домашнее-задание"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Домашнее задание</h2>
<h4><a id="user-content-pam" class="anchor" aria-hidden="true" href="#pam"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>PAM</h4>
<ol>
<li>Запретить всем пользователям, кроме группы admin логин в выходные и праздничные дни</li>
<li>Дать конкретному пользователю права рута</li>
</ol>
<p>Необходимо решить задачу по ограничению доступа пользователей в систему  по  ssh.<br>
Это  будут  пользователи: "day", "night", "friday". Введем для них соответственно ограничения:</p>
<pre><code>●"day" - имеет удаленный доступ каждый день с 8 до 20;
●"night" - с 20 до 8;
●"friday" - в любое время, если сегодня пятница.
</code></pre>
<p>Создадим 3х пользователей:</p>
<pre><code>sudo useradd day &amp;&amp; \ sudo useradd night &amp;&amp; \sudo useradd friday
</code></pre>
<p>Назначим им пароли:</p>
<pre><code>echo "Otus2019"|sudo passwd --stdin day &amp;&amp;\echo "Otus2019" | sudo passwd --stdin night  &amp;&amp;\echo "Otus2019" | sudo passwd --stdin friday
</code></pre>
<p>Чтобы быть уверенными, что на стенде разрешен вход через ssh по паролю выполним:</p>
<pre><code>sed -i 's/^PasswordAuthentication.*$/PasswordAuthentication yes/' /etc/ssh/sshd_config &amp;&amp; systemctl restart sshd.servic
</code></pre>
<p>PAM (Pluggable Authentication Modules - подключаемые модули аутентификации)  -  это набор  библиотек,<br>
которые  позволяют интегрировать  различные  методы  аутентификации  в  виде  единого API,
что позволяет предоставить единые механизмы для управления, встраивания прикладных программ в процесс аутентификации.
PAM решает следующие задачи:</p>
<ul>
<li>Authentication - Аутентификация, идентификация, процесс подтверждения пользователем своей “подлинности”, ввод логина и пароля;</li>
<li>Authorization - Авторизация, процесс наделения пользователя правами (предоставления доступа к каким-либо объектам);</li>
<li>Accounting - Запись информации о произошедших событиях.</li>
</ul>
<p>Таким образом для решения задачи необходимо на первом или втором этапе применить необходимые нам проверки.
Их можно реализвать несколькими способами.
Рассмотрим их</p>
<h3><a id="user-content-pam-модуль-pam_time" class="anchor" aria-hidden="true" href="#pam-модуль-pam_time"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>PAM. Модуль pam_time</h3>
<p>Модуль pam_time позволяет достаточно гибко настроить доступ пользователя с учетом времени.
Настройки данного модуля хранятся в файле /etc/security/time.conf.
Данный файл содержит в себе пояснения и примеры использования.
Добавим в конец файла строки:</p>
<pre><code>*;*;day;Al0800-2000
*;*;night;!Al0800-2000
*;*;friday;Fr

</code></pre>
<p>Разные параметры отделяются символом ";". Разберем первую строку:
● “<em>” сервис, к которому применяется правило
● "</em>" имя терминала, к которому применяется правило
● имя пользователя, для которого данное правило будет действовать
● время, когда правило носит разрешающий характер</p>
<p>Теперь настроим PAM, так как по-умолчанию данный модуль не подключен.
Для этого приведем файл /etc/pam.d/sshd к виду:</p>
<pre><code>...
account    required     pam_nologin.so
account    required     pam_time.so
...
</code></pre>
<p>После чего в отдельном терминале можно проверить доступ к серверу по ssh для созданных пользователей.</p>
<p>PAM. Модуль pam_execЕще один способ реализовать задачу это выполнить при подключении
пользователя скрипт, в котором мы сами обработаем необходимую информацию.
Удалим из /etc/pam.d/sshd
изменения из предыдущего этапа и приведем его к следующему виду:</p>
<pre><code>...
account  required   pam_nologin.so
account  required   pam_exec.so  /usr/local/bin/test_login.sh
...
</code></pre>
<p>Мы добавили модуль pam_exec и, в качестве параметра, указали скрипт,
который осуществит необходимые проверки.</p>
<p>При  запуске  данного  скрипта  PAM-модулем  будет  передана переменная  окружения PAM_USER,
содержащая  имя  пользователя. Скрипт содержит простую логику.
Если имя пользователя friday, то проверям день недели, если пятница, то возвращаем 0,
если нет, то 1 и завершаем скрипт.Если же указан другой пользователь,
то в строке is_day_hours=$(($(test $hour -ge 8; echo $?)+$(test $hour -lt 20; echo $?)))происходит  проверка  принадлжит  ли  текущее  значение  времени (переменная   hour)  диапазону  от  8  до  20  часов.  Если  да,  то is_day_hours примет значение 0, если нет 1. Дальше проверяем имя пользователя  и  соотвествие  ему.  Если  пользователь day  и  часы "дневные",  то  возвращаем  0,  если  пользователь night  и  часы  НЕ дневные,  то  так  же  возвращаем  ноль.  В  противном  случае  скрипт вернет 1. Если в PAM_USER указано какое-то другое имя пользователя, то скрипт вернет 0.На основании кода завершения скрипта модуль pam_exec принимает решение. Если вернулся 0, то все в порядке и пользователь будет авторизован,
в обратном случае нет.
Данный модуль не входит, как предыдущие в базовую систему и должен быть установлен из отдельного репозитория Extra Packages for Enterprise Linux (EPEL).
Подключим репозиторий и установим pam_script:</p>
<pre><code>for pkg in epel-release pam_script; do yum install -y $pkg; done
</code></pre>
<p>Так же как и pam_exec модуль предназначен для выполнения произвольного скрипта в процессе авторизации, аутентификации или аккаунтинга пользователя. По сравнению с предыдущим примером в файле /etc/pam.d/sshdнужно просто переименовать pam_exec в pam_script:</p>
<pre><code>...
account  required  pam_nologin.so
account  required  pam_script.so  /usr/local/bin/test_login.sh
...
</code></pre>
<h3><a id="user-content-pam-модуль-pam_cap" class="anchor" aria-hidden="true" href="#pam-модуль-pam_cap"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>PAM. Модуль pam_cap</h3>
<p>Для демонстрации работы модуля установим дополнительный пакет nmap-ncat(CentOS).
Пользователь day остался из предыдущего примера.
Если стенд пересоздавался, то пользователя так же необходимо создать.
Войдем на стендовую машину под пользователем day и попробуем выполнить команду nc и
получим сообщение об ошибке.
Пример ниже.</p>
<pre><code>ncat -l -p 80Ncat: bind to :::80: Permission denied. QUITTING.
</code></pre>
<p>Это связано с тем, что непривелигерованный пользователь day,
от имени которого выполняется команда,
не может открыть для прослушивания 80й порт</p>
<p>Эту задачу можно решить несколькими способами:
● установить suid-бит. Установка данного бита позволит выполнить ncat так, будто он запущен от root. Способ имеет низкую гибкость, так как установка бита позволит любомупользователю выполнить команду;
● Предоставить пользователю права (возможности), чтобы он смог открыть порт. Способ более гибкий, потому что можно указать что именно, кому и при помощи какой программы мы разрешаем;</p>
<p>Решим задачу вторым способом. Для этого воспользумся pam-модулем pam_cap.
Поскольку это демо стенд, то SELinux можно просто выключить выполнив</p>
<pre><code>setenforce 0
</code></pre>
<h4><a id="user-content-отключать-selinux-в-продакшене-крайне-не-рекомендуется" class="anchor" aria-hidden="true" href="#отключать-selinux-в-продакшене-крайне-не-рекомендуется"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Отключать SELinux в продакшене крайне не рекомендуется!</h4>
<p>Приведем файл /etc/pam.d/sshd к виду:</p>
<pre><code>
...
auth       include      postlogin
auth       required     pam_cap.so
...
</code></pre>
<p>Таким  образом  мы  включили  обработку capabilities  при подключении  по ssh.<br>
Пропишем  необходимые  права  пользователю day.<br>
Для  этого  создадим  файл /etc/security/capability.conf содержащий одну стро</p>
<pre><code>cap_net_bind_service     day
</code></pre>
<p>Теперь необходимо программе (/usr/bin/ncat), при помощи которой будет  открываться  порт,<br>
так  же  выдать  разрешение  на  данное действие</p>
<pre><code> setcap cap_net_bind_service=ei /usr/bin/ncat
</code></pre>
<p>Мы  сопоставили  права,  выданные  пользователю  с  правами выданными на программу. Снова зайдем на стенд под пользователем day и проверим, что мы получили необходимые права:</p>
<h2><a id="user-content-права-администратора" class="anchor" aria-hidden="true" href="#права-администратора"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Права администратора</h2>
<p>Помимо внесения ограничений на вход пользователя в систему,
мы так  же  можем  предоставить  выбранному  пользователю  разные права.
Для  примера  рассмотрим  предоставление  прав  root'а определеному  пользователю  в  системе.<br>
Обычно  для  этого используются следующие варианты</p>
<p>● пользователь заносится в группу wheel;
● для него создается отдельный файл в /etc/sudoers.d/;
● отдельная строка в  /etc/sudoers.</p>
<p>Первый способ реализуется очень просто. Зайдя в систему под root'ом нужно выполнить:</p>
<pre><code>usermod -G wheel day
</code></pre>
<p>Теперь  зайдя  в  систему  под  пользователем day  можно  выполнить команду</p>
<pre><code>sudo  -i 
</code></pre>
<p>и получить консоль пользователя root. При этом будет  запрошен  пароль  того  пользователя,
под  которым осуществлен вход в систему (в данном случае day)</p>
<p>Последующие два способа сводятся к добавлению строки:</p>
<pre><code>day  ALL=(ALL)       ALL
</code></pre>
<p>или</p>
<pre><code>day        ALL=(ALL)       NOPASSWD: ALL
</code></pre>
<p>Первый  вариант  по-прежнему  будет  спрашивать  пароль  текущего пользователя,
а второй нет. Одну  из  приведенных  выше  строк  необходимо  добавить  к  файлу
/etc/sudoers  и  тогда  пользователь day  получит  возможность выполнить 'sudo'.</p>
<p>Вариант  с  созданием  файла /etc/sudoers.d/day  и  добавлением строки в него является более гибким и удобным.</p>
</article>
  </div>

    
